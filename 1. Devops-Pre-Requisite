**********************
**********************
LINUX BASICS
**********************
**********************

⏺ In CLI, various shells include
 Bourne shell (sh)
 C shell (csh or tcsh)
 Z shell (zsh)
 Bourne Again Shell (bash)

⏺ Old Bourne shell = limited
Modern bash shell = advances features such as arithmetic operations, conditionals and arrays.

⏺ To verify which shel you are using
> echo $SHELL

echo = prints text or value of an environment variable, as indicated by $(dollar) sign.

- Executing multiple commands in sequence by separating them with semicolons
> cd new_directory; mkdir www; pwd

⏺ Essential vi Operations :-
(some common operations in command mode)

Operations                   Command                       Description
Navigation                 Arrow keys or h, j, k, l        Move left, down, up and right respectively
Delete a character         x                               Delete the character under the cursor
Delete a line              dd                              Removes the entire line
Copy (yank) a line         yy                              copy the current line into the buffer
Paste copied content       p                               Paste the copied or deleted content
Scroll up                  ctrl + u                        scroll up within the document
scroll down                ctrl + d                        scroll down within the document
Command prompt             :                               Enter further commands (e.g. save, quit)

To manage file operations: 
Save your changes: Type ':w' (you can optionally append a file name)
Quit without saving: Type ':q'
Save and quit: Type ':wq'

Search for text :
To find a word or phrase, switch to command mode and type
> /off
All occurences of "off" will be hihglighted, press 'N' to jump to next match and continue pressing 'N' to cycle through additional matches.


To check current username 
> whoami
To retrieve detailed information about your user account - including user ID, group ID, and group memberships
> id
to switch to another user account
> su aparna


Downloading Files from the Internet :-
To download files such as RPM packages, binaries, or images from the internet. You can use 
'curl' command, which downloads content from a specified URL. The '-O' option saves the output 
directly to a file:
> curl http://www.some-site.com/some-file.txt -O
or
you can use 'wget' command by providing the complete URL of the file.


Package Management
...............................

Package Managers = simplify software installation by automating tasks that would otherwise by manually intensive.

⏺ RPM - Based Package Management
CentOS, Red Hat Enterprise Linux, and Fedora use an RPM-based system.
RPM(Red Hat Package Manager) distributes software in bundles with .rpm extension.

Installing a package: Use '-i' option along with package name to install software from a 
                      specified location.
Uninstalling a package: Use '-e' option to remove a package
Querying package details: Use '-q' option to retrieve information about an installed package.

RPM does no automatically resolve dependencies. Ex, if you install Ansible - which requires Python and additional libraries - using
RPM alone will not install missing dependencies.

> rpm -i telnet.rpm
> rpm -e telnet
> rpm -q telnet

⏺ Dependency Management with Yum
Yum = high level package managers
It integrates with RPM while automating dependency resolution.
> yum install ansible
(yum searches its configured repositories, locates the specified package and its dependencies, and 
installs them in the correct order).

⏺ Understanding Repositories
Yum retrieves packages from software repositories - collections of RPM package stored locally or on remote servers.
'/etc/yum.repos.d' = repository configuration files located
If default repositories do not cover requirements or if latest version needed, then additional
repositories can be configured by following software's documentation.

To list available repositories, 
> yum repolist
To list configuration files that define these repositories
> ls /etc/yum.repos.d/
(Opening any of these files will show a URL pointing to repository location, where you can view RPM files available for download)

Listing installed or available pakcages
let for Ansible
> yum list ansible
Removing an installed package
> yum remove ansible

Listing all available package versions
use the '--showduplicates' option to list all available versions
> yum --showduplicates list ansible


Services
................
Linux services = background processes essential for running software such as webservers, database servers and devops tools.
Ensure critical application continue running after a server restart, start in correct order when multiple services are present, and manage dependency effectively.

software packages that runs in background after installation , are automatically set as a service.
ex: installing apache web server create an HTTPD service.

start HTTPD service with legacy command:
> service httpd start

but we prefer systemctl command:
> systemctl start httpd
> systemctl stop httpd
> systemctl status httpd
> systemctl enable httpd
> systemctl disable httpd

⏺ Configuring a Custom Application as a Service
Let a simple Pytthon-based web server located at '/opt/code/my_app.py'
When executed with Python interpreter , it starts a web server listening on port 5000.

Run command
> /usr/bin/python3 /opt/code/my_app.py
Verify the server is working using
> curl http://localhost:5000
(returns hello world)

By configuring your Python application as  a service, you abstract the need to maually
handle the command line and file paths each time.
Start and stop service with
> systemctl start my_app
> systemctl stop my_app
This approcah simplifies service management and minimizes manual intervention.

⏺ Creating a systemd Unit File
To ensure application starts automatically on boot or restarts if it crashes
These files stored in '/etc/systemd/system'
> vi my_app.service
[Unit]                                      # Provides metadata and a short description of the service
Description=My Python Web Application

[Service]                                   # contains the command to start your application ('ExecStart')
ExecStart=/usr/bin/python3 /opt/code/my_app.py
ExecStartPre=/opt/code/configure_db.sh     #('ExecStartPre') or ('ExecStartPost') optional command that run before or after starting service       
ExecStartPost=/opt/code/email_status.sh
Restart=always          # restart policy

[Install]               # configures the service to begin when the system reaches multi-user target during boot sequence
WantedBy=multi-user.target

Reload systemd to register your new service
> systemctl daemon-reload
Start the service
> systemctl start my_app
> systemctl status my_app
Test service again
> curl http://localhost:5000

Example: The Docker Service
consider docker daemon
After installing Docker, an executable named 'docker' is available at '/usr/bin/docker' and it is configured
as a service using a unit file typically located at '/lib/systemd/system/dockr.service'

After installation, docker daemon automatically runs in background and listens for Docker commands.
This configuration serves as a model for setting up amy custom application as a service.


****************************
****************************
NETWORKING BASICS
****************************
****************************

- 2 computers (VMs) that need to communicate.
Both systems connected to a switch and each host requires and interface - either physical or virtual -
to establish that connection.

To view available interface on linux host
> ip link

Assume network subnet is 192.168.1.0, 
Assign an IP address from this range to each system
on host 1 
> ip addr add 192.168.1.10/24 dev eth0
on host 2
> ip addr add 192.168.1.11/24 dev eth0

Once ip addresses are configured. systems can communicate via switch.
test connectivity with ping
> ping 192.168.1.11

Switch = only facilitates communication within the same network.
Consider second network with CIDR 192.168.2.0 where host IPs might be 192.168.2.10 and 192.168.2.11 
To enable communication b/w systems on network 192.168.1.0 and 192.168.2.0, a router becomes essential.

Router = connects separate networks by using multiple network interfaces.
Assign it IP address 192.168.1.1 on first network and 192.168.2.1 on second .
This configuration les router forward traffic b/w the networks.

https://kodekloud.com/kk-media/image/upload/v1752873510/notes-assets/images/DevOps-Pre-Requisite-Course-Networking-Basics/frame_140.jpg

system B (192.168.1.11) to reach system C (192.168.2.10) must use router as its gateway.

To check current routing table on linux
> route
Without additional configuration. system B can only communicate within its own network.

To route traffic destined for 192.168.2.0 network, add an entry on system B:
> ip route add 192.168.2.0/24 via 192.168.1.1
After adding this route, system B's routing table will reflect that traffic t 192.168.2.0 is forwarded thorugh the router.

- Using the default gateway simplifies routing for internet access.

When systems need internet access - such as reaching Google within the 172.217.104.0 network - the router connected to th internet mist be desginated
as default gateway.
To set up a default route
> ip route add default via 192.168.2.1
This default route catches any packet destined for an unspecified network.
> route

- Both "default" keyword and "0.0.0.0" entry function as catch-all destinations for packets 
  that do not match more specific routes.

- In environments with multiple routers, such as one handling internet traffic and another for internet networks, you must create separate routing entries.
Ex, if traffic destined for network 192.168.1.0 should use a router at 192.168.2.2 while all other uses
192.168.2.1 as default gateway, set route as
> ip route add 192.168.1.0/24 via 192.168.2.2
> route


Setting up Linux as a Router
----------------------------------
Consider configuring a linux host as a router.

Three hosts, A, B and C
Hosts A and B belong to 192.168.1.0 network
Hosts B and C are part of 192.168.2.0 network.
Host B connects to both networks via two interfaces - etho and eth1 with IP addresses 192.168.1.6 and 192.168.2.6 res.
Host A has IP address 192.168.1.5 and C has 192.168.2.5

If host A pings host C 
> ping 192.168.2.5
(network unreachable)
Error occurs bcoz host A doesnot know to use host B as gateway to reach 192.168.2.0
To resolve this, add a route on host A,
> ip route add 192.168.2.0/24 via 192.168.1.6
SImilarly, inform host C to use host B as its gateway for 192.168.1.0 network:
> ip route add 192.168.1.0/24 via 192.168.2.6

Once these routes are added, host A can reach host C.
However, you might still not receive any ping responses bcoz Linux by defaul donot forward
packets b/w interfaces - a security measure to prevent unitended bridging of networks.

To check if IP forwarding is enables, inspect /proc/sys/net/ipv4/ip_forward
To determine if IP forwarding is enabled,
> cat /proc/sys/net/ipv4/ip_forward
# Expected output:
# 0
Since output is 0, packet forwarding is disabled.

To enable it temporarily
> echo 1 > /proc/sys/net/ipv4/ip_forward
now, ping from host A to host c
> ping 192.168.2.5

This change does not persist after a reboot.
To enable permanent IP forwarding, modify the configuration in /etc/sysctl.conf file.


DNS
---------------
Imaging you have 2 computers A and B on same network with IPs 192.168.1.10 and 192.168.1.11 res.
verify connectivity
> ping 192.168.1.11

suppose system B provides database servics, so to refer to it "db"
ping "db" from system A 
> ping db
(unknown host db)

To reolve this add an entry to '/etc/hosts' file on system A to map IP address to name "db"
> cat >> /etc/hosts
192.168.1.11 db
> ping db

System A relies entierely on '/etc/hosts' entry for name resolution. It does not verify whether system B's
actual hostname (as reported by 'hostname') matches "db".

You can also add multiple alias for same IP address
> cat >> /etc/hosts
192.168.1.11 db
192.168.1.11 www.google.com

After this both names will resolve to 192.168.1.11
> ping db
> ping www.google.com

Each time you reference a hostname - whether using ping, SSH or curl , the system first checks 
the '/etc/hosts' file
> cat >> /etc/hosts
192.168.1.11 db
192.168.1.11 www.google.com
> ping db
> ssh db
> curl http://www.google.com

- THis translation of a hostname to an IP address is known as name resolution.
- While managing small networks via local '/etc/hosts' files works well, maintaining consistency
  bcomes difficult as the number of hosts increases.
- If a server's IP address changes , updating the '/etc/hosts' file on every host can be major headache.
- A centralized DNS server eliminates this problem.


Centralizing DNS with a DNS Server
-----------------------------------------

















































